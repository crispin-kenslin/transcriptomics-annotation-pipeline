{% extends "base.html" %}
{% block title %}Launch a Run{% endblock %}
{% block content %}
<section class="card reveal-up" id="launch-form">
    <div class="card-header">
        <div>
            <p class="eyebrow">Differential expression</p>
            <h2>Configure a new run</h2>
            <p class="lede">Auto column detection reduces setup time; manual overrides keep reviewers confident.</p>
        </div>
        <div class="species-chip" id="species-chip">Auto plant detection</div>
    </div>
    <form class="grid" action="{{ request.url_for('run_pipeline') }}" method="post" enctype="multipart/form-data">
        <div class="field span-2">
            <label for="data_file">Expression file (CSV)</label>
            <input id="data_file" name="data_file" type="file" accept=".csv" required />
            <p class="hint">Minimum columns: gene ID, log2 fold change, and p-value.</p>
        </div>
        <div class="field span-2">
            <label for="job_name">Job name (optional)</label>
            <input id="job_name" name="job_name" type="text" maxlength="120" placeholder="e.g. drought_vs_control" />
            <p class="hint">Appears in history, logs, and the Dash interface.</p>
        </div>
        <div class="field span-2">
            <label for="species_key">Plant species</label>
            <select id="species_key" name="species_key">
                <option value="auto" selected>Auto detect (recommended)</option>
                {% for opt in species_options %}
                <option value="{{ opt.key }}">{{ opt.label }}</option>
                {% endfor %}
            </select>
            <p class="hint">Auto mode scans locus prefixes; override to pin STRING/UniProt IDs.</p>
        </div>
        <div class="field">
            <label for="gene_col">Gene ID column</label>
            <select id="gene_col" name="gene_col" required>
                <option value="" disabled selected>Select after upload</option>
            </select>
        </div>
        <div class="field">
            <label for="log2fc_col">log2FC column</label>
            <select id="log2fc_col" name="log2fc_col" required>
                <option value="" disabled selected>Select after upload</option>
            </select>
        </div>
        <div class="field">
            <label for="pval_col">p-value column</label>
            <select id="pval_col" name="pval_col" required>
                <option value="" disabled selected>Select after upload</option>
            </select>
        </div>
        <div class="field" id="adj-field" style="display:none;">
            <label for="adj_p_col">Adjusted p-value column</label>
            <select id="adj_p_col" name="adj_p_col">
                <option value="" selected>Auto-calculate during run</option>
            </select>
            <p class="hint">Select a Benjamini–Hochberg/FDR column if your CSV already contains one.</p>
        </div>
        <div class="field">
            <label for="log2fc_threshold">log2FC threshold</label>
            <input id="log2fc_threshold" name="log2fc_threshold" type="number" step="0.01" value="1.0" />
        </div>
        <div class="field">
            <label for="pvalue_threshold">p-value threshold</label>
            <input id="pvalue_threshold" name="pvalue_threshold" type="number" step="0.0001" value="0.05" />
        </div>
        <div class="field">
            <label for="distance_percentile">Distance percentile</label>
            <input id="distance_percentile" name="distance_percentile" type="number" step="1" value="95" />
        </div>
        <div class="field">
            <label class="checkbox">
                <input id="use_fdr" name="use_fdr" type="checkbox" />
                <span>Use FDR-adjusted p-values</span>
            </label>
            <p class="hint">When enabled, TAP uses your adjusted column or computes BH corrections before filtering.</p>
        </div>
        <div class="actions span-2">
            <button type="submit" class="btn primary">Run pipeline</button>
        </div>
    </form>
</section>

<script>
    const fileInput = document.getElementById('data_file');
    const speciesSelect = document.getElementById('species_key');
    const speciesChip = document.getElementById('species-chip');
    const fdrToggle = document.getElementById('use_fdr');
    const adjField = document.getElementById('adj-field');
    const adjSelect = document.getElementById('adj_p_col');
    const selects = {
        gene: document.getElementById('gene_col'),
        log2fc: document.getElementById('log2fc_col'),
        pval: document.getElementById('pval_col')
    };

    function setChipText(text) {
        if (speciesChip) speciesChip.textContent = text;
    }

    if (speciesSelect) {
        speciesSelect.addEventListener('change', () => {
            if (speciesSelect.value === 'auto') {
                setChipText('Auto plant detection');
            } else {
                const label = speciesSelect.options[speciesSelect.selectedIndex]?.text || speciesSelect.value;
                setChipText(`Pinned species · ${label}`);
            }
        });
    }

    function toggleAdjField() {
        const show = fdrToggle?.checked;
        if (!adjField || !adjSelect) return;
        adjField.style.display = show ? 'flex' : 'none';
        if (!show) {
            adjSelect.value = '';
        }
    }

    if (fdrToggle) {
        fdrToggle.addEventListener('change', toggleAdjField);
    }

    function clearOptions(sel, includeDefault = false) {
        sel.innerHTML = includeDefault ? '<option value="" selected>Auto-calculate during run</option>' : '<option value="" disabled selected>Select after upload</option>';
    }

    function populateColumns(cols) {
        const defaults = {
            gene: ['gene_id', 'Gene', 'GeneID'],
            log2fc: ['log2FC', 'logFC'],
            pval: ['p_value', 'pvalue', 'pval'],
            adj: ['adj_p_value', 'padj', 'FDR', 'q_value']
        };
        clearOptions(selects.gene);
        clearOptions(selects.log2fc);
        clearOptions(selects.pval);
        if (adjSelect) clearOptions(adjSelect, true);
        cols.forEach(col => {
            [selects.gene, selects.log2fc, selects.pval].forEach(sel => {
                const opt = document.createElement('option');
                opt.value = col;
                opt.textContent = col;
                sel.appendChild(opt.cloneNode(true));
            });
            if (adjSelect) {
                const adjOpt = document.createElement('option');
                adjOpt.value = col;
                adjOpt.textContent = col;
                adjSelect.appendChild(adjOpt);
            }
        });
        const pickDefault = (sel, prefs) => {
            for (const pref of prefs) {
                const opt = [...sel.options].find(o => o.value.toLowerCase() === pref.toLowerCase());
                if (opt) { sel.value = opt.value; return; }
            }
        };
        pickDefault(selects.gene, defaults.gene);
        pickDefault(selects.log2fc, defaults.log2fc);
        pickDefault(selects.pval, defaults.pval);
        if (adjSelect) pickDefault(adjSelect, defaults.adj);
    }

    fileInput?.addEventListener('change', e => {
        const file = e.target.files?.[0];
        if (!file) {
            Object.values(selects).forEach(sel => clearOptions(sel));
            if (adjSelect) clearOptions(adjSelect, true);
            return;
        }
        const reader = new FileReader();
        reader.onload = ev => {
            try {
                const text = ev.target.result;
                const firstLine = String(text).split(/\r?\n/)[0];
                const cols = firstLine.split(',').map(c => c.trim()).filter(Boolean);
                if (cols.length) populateColumns(cols);
            } catch (err) {
                console.error('Header parse failed', err);
                Object.values(selects).forEach(sel => clearOptions(sel));
                if (adjSelect) clearOptions(adjSelect, true);
            }
        };
        reader.readAsText(file.slice(0, 2000));
    });

    document.querySelectorAll('.created-at').forEach(el => {
        const utc = el.getAttribute('data-utc');
        if (!utc) return;
        const date = new Date(utc);
        if (Number.isNaN(date.getTime())) return;
        const opts = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false };
        el.textContent = date.toLocaleString(undefined, opts);
        el.title = `UTC: ${utc}`;
    });

    document.querySelectorAll('.stop-run').forEach(btn => {
        btn.addEventListener('click', async () => {
            const runId = btn.getAttribute('data-run-id');
            if (!runId) return;
            if (!confirm(`Stop run ${runId}?`)) return;
            btn.disabled = true;
            btn.textContent = 'Stopping...';
            try {
                const res = await fetch(`/runs/${runId}/stop`, { method: 'POST' });
                if (!res.ok) throw new Error('Request failed');
                location.reload();
            } catch (err) {
                console.error(err);
                btn.disabled = false;
                btn.textContent = 'Stop';
                alert('Failed to stop run.');
            }
        });
    });

    const resumeForm = document.getElementById('resume-form');
    const resumeInput = document.getElementById('resume-run-id');
    if (resumeForm && resumeInput) {
        resumeForm.addEventListener('submit', evt => {
            evt.preventDefault();
            const runId = resumeInput.value.trim();
            if (!runId) return;
            window.location.href = `/runs/${encodeURIComponent(runId)}/results`;
        });
    }

    toggleAdjField();
</script>
{% endblock %}
